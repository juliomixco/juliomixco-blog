{"componentChunkName":"component---src-templates-blog-post-js","path":"/articles/typescript-generics-intro/","result":{"data":{"markdownRemark":{"html":"<p>In this article, you are going to learn how to keep your type checks, create reusable functions and types, and also the importance and benefits of choosing your types correctly.</p>\n<h2>The Problem</h2>\n<p>While you are coding, you might find yourself writing duplicated code and instantly wondering how to make it more <em>DRY</em> (Don't repeat yourself).\nIn this case, you would extract the reused code into a function or class and then proceed to remove the duplicated code from your codebase.</p>\n<p>While you are trying to create reusable code, the first thing that may come to your mind is using <em>any</em>, but that is entirely wrong, as soon as you begin using <em>any</em> you lose all the advantages typescript has to offer.</p>\n<figure>\n  <p>\n    <a href=\"https://dev-to-uploads.s3.amazonaws.com/i/uphkogn28imle6kxu6y8.gif\" class=\"article-body-image-wrapper\">\n      <img src=\"https://dev-to-uploads.s3.amazonaws.com/i/uphkogn28imle6kxu6y8.gif\" alt=\"Type checks while using any\" loading=\"lazy\">\n    </a>\n  </p>\n  <figcaption>While you are using <b>any</b> you lose all typechecks</figcaption>\n</figure>\n<p>As you can see in the example code above, while you are using <em>any</em>, the compiler cannot perform any type checks on the function parameters and cannot tell what the return type is, So it just types it as <em>any</em>.\nAs you may know, a variable typed as <a href=\"https://www.typescriptlang.org/docs/handbook/basic-types.html#any\"><em>any</em></a> can be assigned any value type. That's why we can pass objects and functions as function parameters.</p>\n<p>While you were using <em>any</em>, the compiler was not able to provide any <em>Type</em> information, autocompletion, or IntelliSense to the developer. There are two ways of recovering the type checks:</p>\n<ol>\n<li>Tell the compiler the exact Type of the variable, but this requires the developer to set it correctly, plus it's prone to human error.</li>\n<li>Use Generics.</li>\n</ol>\n<p><strong>Rule of thumb</strong>: Avoid using <a href=\"https://www.typescriptlang.org/docs/handbook/basic-types.html#any\"><em>any</em></a>, you should be able to find a better alternative almost every time.</p>\n<h2>Generics to the Rescue</h2>\n<p>What are Generics? In simple words, Generic types are a way of creating re-usable types or let the compiler infer the type of property, parameter, or function. These features allow us to compose types this way, creating even more complex objects.f</p>\n<figure>\n  <p>\n    <a href=\"https://dev-to-uploads.s3.amazonaws.com/i/uvad3j1q4ijm56bffn9b.gif\" class=\"article-body-image-wrapper\">\n      <img src=\"https://dev-to-uploads.s3.amazonaws.com/i/uvad3j1q4ijm56bffn9b.gif\" alt=\"Type checks while using generics\" loading=\"lazy\">\n    </a>\n  </p>\n  <figcaption>By using generics the compiler is able to infer the correct type for each parameter, this also works for the return type</figcaption>\n</figure>\n<p>The code above uses generics, and you can quickly tell that by doing so, you have recovered the type checks on your code. Now the compiler can infer the correct parameter types and return types of the function. That's why now those parameters that shouldn't be accepted are underlined by the squiggly red line.</p>\n<p>But what does that thing <code>&#x3C;T></code> even mean ðŸ˜¨?\nWell, that is commonly called <em>diamond interface</em>, <em>diamond operator</em> or just <em>angle brackets</em> you can imagine it like this, just like <code>()</code> serves for declaring function parameters, <code>&#x3C;></code> serves for declaring Type parameters. So, in this case, <code>T</code> is a type parameter for our function, in the previous example, typescript inferred the type of <em>T</em>, but you can tell the compiler explicitly what type you expect it to be.</p>\n<p><img src=\"https://dev-to-uploads.s3.amazonaws.com/i/s4vq06ipmcqvlh6rdevx.gif\" alt=\"explicit type parameter\"></p>\n<p>In the example above, by placing the expected Type between the angle brackets, we are setting explicitly the type we expect the function's parameters to be. Here <code>excludeValueTyped&#x3C;string>(numberArray, \"199\");</code> we tell the function that <code>T</code> is of type <em>string</em> therefore <em>source</em> is now of type <code>string[]</code> and <em>excludedVal</em> is now of type <em>string</em> That's why <em>numberArray</em> of type <code>number[]</code> is marked with an error.</p>\n<p>I invite you to experiment with this code so you can better understand what is going on with the compiler. Try to set the correct types explicitly and make sure the te parameters match with the correct type.</p>\n\n        <deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">const numberArray = [1, 23, 45, 199, 34, 5]\nconst stringArray = [&quot;using&quot;, &quot;generics&quot;, &quot;is&quot;, &quot;cool&quot;]\n\nfunction excludeValueTyped&lt;T&gt;(source: T[], excludedVal: T): T[] {\n  return source.filter(e =&gt; e !== excludedVal)\n}\n\nlet filteredNumbers = excludeValueTyped&lt;string&gt;(numberArray, &quot;199&quot;)\nfilteredNumbers = excludeValueTyped&lt;boolean&gt;(numberArray, 100)\n\nlet filteredStrings = excludeValueTyped&lt;number&gt;(stringArray, &quot;any&quot;)\nfilteredStrings = excludeValueTyped(stringArray, {})\nfilteredStrings = excludeValueTyped&lt;Function&gt;(stringArray, () =&gt; {})</code>\n        </deckgo-highlight-code>\n      \n<h2>Generic Interfaces and Classes</h2>\n<p>We are also able to create Generic Interfaces and Classes that can be composed into even more complex Types.</p>\n<h3>The issue</h3>\n<p>Imagine that you are requesting data to a REST API, and every response has an envelope. When you define the interfaces that describe the responses of each endpoint, you will create something like this.</p>\n\n        <deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">export interface Product {\n  name: string\n  description: string\n  unitPrice: number\n  category: Category\n}\n\nexport interface Category {\n  name: string\n  description: string\n}\n\nexport interface ProductListResponse {\n  statusCode: number\n  result: Product[]\n  errors?: Error[]\n}\n\nexport interface ProductDetailResponse {\n  statusCode: number\n  result: Product\n  errors?: Error[]\n}\nexport interface CategoryListResponse {\n  statusCode: number\n  result: Category[]\n  errors?: Error[]\n}\nexport interface CategoryDetailResponse {\n  statusCode: number\n  result: Category\n  errors?: Error[]\n}</code>\n        </deckgo-highlight-code>\n      \n<p>As you can tell, the code above doesn't feel just ok. I mean, it works, but there is some room for improvement and opportunity to remove duplicated lines of code.\nEach Response has the same properties in common, and it seems like a waste of effort and space, writing them over and over again. Besides that, later on, if the API developers decide to incorporate another field to the response envelope. The maintenance cost of each response increases for each Response Interface you define.</p>\n<h3>The Solution</h3>\n<p>Here comes once again Generics to the rescue. What we need to do is identify the properties in common and move them to a reusable <em>Interface</em>.\nThe use of Generics in <em>Interfaces</em> is similar to functions. You have to append the angle brackets to the interface's name like this <code>MyGenericInterface&#x3C;T></code> and pass the Type parameters.</p>\n\n        <deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">export interface Product {\n  name: string\n  description: string\n  unitPrice: number\n  category: Category\n}\n\nexport interface Category {\n  name: string\n  description: string\n}\n\nexport interface ApiResponse&lt;T&gt; {\n  statusCode: number\n  result: T\n  errors?: Error[]\n}\n\nexport type ProductListResponse = ApiResponse&lt;Product[]&gt;\nexport type ProductDetailResponse = ApiResponse&lt;Product&gt;\nexport type CategoryListResponse = ApiResponse&lt;Category[]&gt;\nexport type CategoryDetailResponse = ApiResponse&lt;Category&gt;\n\nexport const productListResponse: ApiResponse&lt;Product[]&gt; = {}\nexport const productDetailResponse: ProductDetailResponse = {}\nexport const categoryListResponse: CategoryListResponse = {}\nexport const categoryDetailResponse: ApiResponse&lt;Category&gt; = {}</code>\n        </deckgo-highlight-code>\n      \n<p>In the example above, we create a generic <em>Interface</em> that takes <code>T</code> as a Type Parameter and sets it to <em>Result</em> <code>ApiResponse&#x3C;T></code> this way, you have only one wrapper defined and you have to define each <em>Result</em> type. The benefits of using this syntax are immediate. Now you can easily compose <em>Types</em>, define <em>Type aliases</em>, and if you try to assign a value to each <em>const</em>, the editor helps you auto-complete each object's properties.</p>\n<p>As you can see in the code above, I assigned each <em>const</em> a Type. Some of them are aliases, and the other ones are Interfaces composed inline. I've intentionally done that composition, so you can notice it makes no difference the way you assign the type. You always get the same benefits.</p>\n<p><strong>Pro tip</strong>: in Visual Studio Code you can activate <a href=\"https://code.visualstudio.com/docs/editor/intellisense\">Intellisense</a> (code completion) by placing your cursor inside the empty object and pressing\n<kbd>Ctrl</kbd>+<kbd>Space</kbd></p>\n<p>Wait, what's that? Now they added a paginated endpoint ðŸ˜². No problem, you only need to create another <em>Generic Interface</em> to define the shape of the pagination wrapper.</p>\n\n        <deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">export interface Product {\n  name: string\n  description: string\n  unitPrice: number\n  category: Category\n}\nexport interface ApiResponse&lt;T&gt; {\n  statusCode: number\n  result: T\n  errors?: Error[]\n}\n\nexport interface PagedResponse&lt;T&gt; {\n  currentPage: number\n  pageCount: number\n  pageSize: number\n  rowCount: number\n  firstRowOnPage: number\n  lastRowOnPage: number\n  items: T[]\n}\n\nexport type PaginatedResponse&lt;T&gt; = ApiResponse&lt;PagedResponse&lt;T&gt;&gt;\n\nexport type PaginatedProductListResponse1 = ApiResponse&lt;PagedResponse&lt;Product&gt;&gt;\nexport type PaginatedProductListResponse2 = PaginatedResponse&lt;Product&gt;</code>\n        </deckgo-highlight-code>\n      \n<p>In the example above, I created the interface <code>PagedResponse&#x3C;T></code> that defines the shape of the pagination object. Once created, I can create composite Types by defining <em>Type aliases</em> that can also be generic by themselves.\nIf you are still confused about what is the shape of the composed type, <code>ApiResponse&#x3C;PagedResponse&#x3C;Product>></code> looks like, here is an example of it to help you better understand what's going on.</p>\n\n        <deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">// shape of ApiResponse&lt;PagedResponse&lt;Product&gt;&gt;\n{\n  // ApiResponse\n  statusCode: number;\n  result: {\n    // PagedResponse\n    currentPage: number;\n    pageCount: number;\n    pageSize: number;\n    rowCount: number;\n    firstRowOnPage: number;\n    lastRowOnPage: number;\n    items: {\n      // Product\n      name: string;\n      description: string;\n      unitPrice: number;\n      category: Category;\n    }[];\n  };\n  errors?: Error[];\n}</code>\n        </deckgo-highlight-code>\n      \n<p>The same principles apply when defining generic classes. The following is an example of how you can do it.</p>\n\n        <deckgo-highlight-code language=\"typescript\"  >\n          <code slot=\"code\">export class MyBaseClass&lt;T&gt; {\n  constructor(param: T) {\n    console.log(param)\n  }\n}\nexport class MyClass&lt;T, K, ValType&gt; extends MyBaseClass&lt;ValType&gt; {\n  private field: T\n  getValue(): T {\n    return this.field\n  }\n  setValue(value: K) {}\n  convertVal&lt;ValType&gt;(): ValType[] {\n    // ... process it\n    return []\n  }\n}</code>\n        </deckgo-highlight-code>\n      \n<p><img src=\"https://media.giphy.com/media/XreQmk7ETCak0/giphy.gif\" alt=\"Looks Good\"></p>\n  <figcaption>Looking Good!</figcaption>\n<p><strong>Now go and recover your type checks!!</strong>\nIn this article, I talked about the many benefits of using generics and some of the problems they solve. I have seen many new developers struggle with <em>any</em> and losing their type checks. After reading this article, I hope you go to your code, remove most of the <em>any</em> you've used, and refactor it to be generic.</p>\n<p>Thanks for reading,\nJulio Mixco</p>","frontmatter":{"title":"TypeScript Generics - Recover your type checks and IntelliSense"},"excerpt":"In this article, you are going to learn how to keep your type checks, create reusable functions and types, and also the importance andâ€¦"}},"pageContext":{"slug":"/articles/typescript-generics-intro/"}}}